"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.processNode = void 0;

var _gatsbyPluginSharp = require("gatsby-plugin-sharp");

var _gatsbyImage = _interopRequireDefault(require("gatsby-image"));

var _react = _interopRequireDefault(require("react"));

var _server = _interopRequireDefault(require("react-dom/server"));

var _fastJsonStableStringify = _interopRequireDefault(require("fast-json-stable-stringify"));

var _execall = _interopRequireDefault(require("execall"));

var _cheerio = _interopRequireDefault(require("cheerio"));

var _url = _interopRequireDefault(require("url"));

var _path = _interopRequireDefault(require("path"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _supportedExtensions = require("gatsby-transformer-sharp/supported-extensions");

var _formatLogMessage = require("../../../utils/format-log-message");

var _index = _interopRequireDefault(require("./create-remote-file-node/index"));

var _fetchReferencedMediaItems = _interopRequireWildcard(require("../fetch-nodes/fetch-referenced-media-items"));

var _btoa = _interopRequireDefault(require("btoa"));

var _store = _interopRequireDefault(require("../../../store"));

// @todo this doesn't make sense because these aren't all images
const imgSrcRemoteFileRegex = /(?:src=\\")((?:(?:https?|ftp|file):\/\/|www\.|ftp\.)(?:\([-A-Z0-9+&@#/%=~_|$?!:,.]*\)|[-A-Z0-9+&@#/%=~_|$?!:,.])*(?:\([-A-Z0-9+&@#/%=~_|$?!:,.]*\)|[A-Z0-9+&@#/%=~_|$])\.(?:jpeg|jpg|png|gif|ico|pdf|doc|docx|ppt|pptx|pps|ppsx|odt|xls|psd|mp3|m4a|ogg|wav|mp4|m4v|mov|wmv|avi|mpg|ogv|3gp|3g2|svg|bmp|tif|tiff|asf|asx|wm|wmx|divx|flv|qt|mpe|webm|mkv|tt|asc|c|cc|h|csv|tsv|ics|rtx|css|htm|html|m4b|ra|ram|mid|midi|wax|mka|rtf|js|swf|class|tar|zip|gz|gzip|rar|7z|exe|pot|wri|xla|xlt|xlw|mdb|mpp|docm|dotx|dotm|xlsm|xlsb|xltx|xltm|xlam|pptm|ppsm|potx|potm|ppam|sldx|sldm|onetoc|onetoc2|onetmp|onepkg|odp|ods|odg|odc|odb|odf|wp|wpd|key|numbers|pages))(?=\\"| |\.)/gim;
const imgTagRegex = /<img([\w\W]+?)[\/]?>/gim;

const getNodeEditLink = node => {
  const {
    protocol,
    hostname
  } = _url.default.parse(node.link);

  const editUrl = `${protocol}//${hostname}/wp-admin/post.php?post=${node.databaseId}&action=edit`;
  return editUrl;
};

const findReferencedImageNodeIds = ({
  nodeString,
  pluginOptions,
  node
}) => {
  // if the lazyNodes plugin option is set we don't need to find
  // image node id's because those nodes will be fetched lazily in resolvers
  if (pluginOptions.type.MediaItem.lazyNodes) {
    return [];
  } // get an array of all referenced media file ID's


  const matchedIds = (0, _execall.default)(/"id":"([^"]*)","sourceUrl"/gm, nodeString).map(match => match.subMatches[0]).filter(id => id !== node.id);
  return matchedIds;
};

const getCheerioImgDbId = cheerioImg => {
  // try to get the db id from data attributes
  const dataAttributeId = cheerioImg.attribs[`data-id`] || cheerioImg.attribs[`data-image-id`];

  if (dataAttributeId) {
    return dataAttributeId;
  }

  if (!cheerioImg.attribs.class) {
    return null;
  } // try to get the db id from the wp-image-id classname


  const wpImageClass = cheerioImg.attribs.class.split(` `).find(className => className.includes(`wp-image-`));

  if (wpImageClass) {
    const wpImageClassDashArray = wpImageClass.split(`-`);
    const wpImageClassId = Number(wpImageClassDashArray[wpImageClassDashArray.length - 1]);

    if (wpImageClassId) {
      return wpImageClassId;
    }
  }

  return null;
};

const dbIdToMediaItemRelayId = dbId => dbId ? (0, _btoa.default)(`post:${dbId}`) : null;

const getCheerioImgRelayId = cheerioImg => dbIdToMediaItemRelayId(getCheerioImgDbId(cheerioImg));

const fetchNodeHtmlImageMediaItemNodes = async ({
  cheerioImages,
  nodeString,
  node,
  helpers,
  pluginOptions
}) => {
  // @todo check if we have any of these nodes locally already
  const mediaItemUrls = cheerioImages.map(({
    cheerioImg
  }) => cheerioImg.attribs.src); // build a query to fetch all media items that we don't already have

  const mediaItemNodesBySourceUrl = await (0, _fetchReferencedMediaItems.default)({
    mediaItemUrls
  }); // images that have been edited from the media library that were previously
  // uploaded to a post/page will have a different sourceUrl so they can't be fetched by it
  // in many cases we have data-id or data-image-id as attributes on the img
  // we can try to use those to fetch media item nodes as well
  // this will keep us from missing nodes

  const mediaItemDbIds = cheerioImages.map(({
    cheerioImg
  }) => getCheerioImgDbId(cheerioImg)).filter(Boolean); // media items are of the post type

  const mediaItemRelayIds = mediaItemDbIds.map(dbId => dbIdToMediaItemRelayId(dbId)).filter( // filter out any media item ids we already fetched
  relayId => !mediaItemNodesBySourceUrl.find(({
    id
  }) => id === relayId));
  const mediaItemNodesById = await (0, _fetchReferencedMediaItems.default)({
    referencedMediaItemNodeIds: mediaItemRelayIds
  }); // get all the image nodes we've cached from elsewhere

  const {
    nodeMetaByUrl
  } = _store.default.getState().imageNodes;

  const previouslyCachedNodesByUrl = await Promise.all(Object.entries(nodeMetaByUrl).map(([sourceUrl, {
    id
  }]) => {
    var _helpers$getNode;

    return Object.assign({
      sourceUrl
    }, (_helpers$getNode = helpers.getNode(id)) !== null && _helpers$getNode !== void 0 ? _helpers$getNode : {});
  }));
  const mediaItemNodes = [...mediaItemNodesById, ...mediaItemNodesBySourceUrl, ...previouslyCachedNodesByUrl];
  const htmlMatchesToMediaItemNodesMap = new Map();

  for (const {
    cheerioImg,
    match
  } of cheerioImages) {
    const htmlImgSrc = cheerioImg.attribs.src;
    const possibleHtmlSrcs = [// try to match the media item source url by original html src
    htmlImgSrc, // or by the src minus any image sizes string
    (0, _fetchReferencedMediaItems.stripImageSizesFromUrl)(htmlImgSrc)];
    let imageNode = mediaItemNodes.find(mediaItemNode => // either find our node by the source url
    possibleHtmlSrcs.includes(mediaItemNode.sourceUrl) || // or by id for cases where the src url didn't return a node
    getCheerioImgRelayId(cheerioImg) === mediaItemNode.id);

    if (!imageNode && htmlImgSrc) {
      // if we didn't get a media item node for this image,
      // we need to fetch it and create a file node for it with no
      // media item node.
      try {
        const htaccessCredentials = pluginOptions.auth.htaccess;
        imageNode = await (0, _index.default)(Object.assign({
          url: htmlImgSrc,
          // fixedBarTotal,
          parentNodeId: node.id,
          auth: htaccessCredentials ? {
            htaccess_pass: htaccessCredentials === null || htaccessCredentials === void 0 ? void 0 : htaccessCredentials.password,
            htaccess_user: htaccessCredentials === null || htaccessCredentials === void 0 ? void 0 : htaccessCredentials.username
          } : null
        }, helpers, {
          createNode: helpers.actions.createNode
        }));
      } catch (e) {
        if (typeof e === `string` && e.includes(`404`)) {
          var _node$title;

          const nodeEditLink = getNodeEditLink(node);
          helpers.reporter.log(``);
          helpers.reporter.warn((0, _formatLogMessage.formatLogMessage)(`\n\nReceived a 404 when trying to fetch\n${htmlImgSrc}\nfrom ${node.__typename} #${node.databaseId} "${(_node$title = node.title) !== null && _node$title !== void 0 ? _node$title : node.id}"\n\nMost likely this image was uploaded to this ${node.__typename} and then deleted from the media library.\nYou'll need to fix this and re-save this ${node.__typename} to remove this warning at\n${nodeEditLink}.\n\n`));
          imageNode = null;
        } else {
          helpers.reporter.panic((0, _formatLogMessage.formatLogMessage)(e));
        }
      } // save any fetched media items in our global media item cache


      _store.default.dispatch.imageNodes.pushNodeMeta({
        sourceUrl: htmlImgSrc,
        id: imageNode.id,
        modifiedGmt: imageNode.modifiedGmt
      });
    }

    if (imageNode) {
      // match is the html string of the img tag
      htmlMatchesToMediaItemNodesMap.set(match, {
        imageNode,
        cheerioImg
      });
    }
  }

  return htmlMatchesToMediaItemNodesMap;
};

const getCheerioImgFromMatch = ({
  match
}) => {
  // unescape quotes
  const parsedMatch = JSON.parse(`"${match}"`); // load our matching img tag into cheerio

  const $ = _cheerio.default.load(parsedMatch, {
    xml: {
      // make sure it's not wrapped in <body></body>
      withDomLvl1: false,
      // no need to normalize whitespace, we're dealing with a single element here
      normalizeWhitespace: false,
      xmlMode: true,
      // entity decoding isn't our job here, that will be the responsibility of WPGQL
      // or of the source plugin elsewhere.
      decodeEntities: false
    }
  }); // there's only ever one image due to our match matching a single img tag
  // $(`img`) isn't an array, it's an object with a key of 0


  const cheerioImg = $(`img`)[0];
  return {
    match,
    cheerioImg
  };
};

const getLargestSizeFromSizesAttribute = sizesString => {
  const sizesStringsArray = sizesString.split(`,`);
  return sizesStringsArray.reduce((largest, currentSizeString) => {
    const maxWidth = currentSizeString.substring(currentSizeString.indexOf(`max-width: `) + 1, currentSizeString.indexOf(`px`)).trim();
    const maxWidthNumber = Number(maxWidth);
    const noLargestAndMaxWidthIsANumber = !largest && !isNaN(maxWidthNumber);
    const maxWidthIsALargerNumberThanLargest = largest && !isNaN(maxWidthNumber) && maxWidthNumber > largest;

    if (noLargestAndMaxWidthIsANumber || maxWidthIsALargerNumberThanLargest) {
      largest = maxWidthNumber;
    }

    return largest;
  }, null);
};

const findImgTagMaxWidthFromCheerioImg = cheerioImg => {
  const {
    attribs: {
      width,
      sizes
    }
  } = cheerioImg || {
    attribs: {
      width: null,
      sizes: null
    }
  };

  if (width) {
    const widthNumber = Number(width);

    if (!isNaN(widthNumber)) {
      return widthNumber;
    }
  }

  if (sizes) {
    const largestSize = getLargestSizeFromSizesAttribute(sizes);

    if (largestSize && !isNaN(largestSize)) {
      return largestSize;
    }
  }

  return null;
};

const replaceNodeHtmlImages = async ({
  nodeString,
  node,
  helpers,
  wpUrl,
  pluginOptions
}) => {
  var _pluginOptions$html;

  // this prevents fetching inline html images
  if (!(pluginOptions === null || pluginOptions === void 0 ? void 0 : (_pluginOptions$html = pluginOptions.html) === null || _pluginOptions$html === void 0 ? void 0 : _pluginOptions$html.useGatsbyImage)) {
    return nodeString;
  }

  const imageUrlMatches = (0, _execall.default)(imgSrcRemoteFileRegex, nodeString);
  const imgTagMatches = (0, _execall.default)(imgTagRegex, nodeString).filter(({
    match
  }) => {
    // @todo make it a plugin option to fetch non-wp images
    // here we're filtering out image tags that don't contain our site url
    const isHostedInWp = match.includes(wpUrl);
    return isHostedInWp;
  });

  if (imageUrlMatches.length) {
    const cheerioImages = imgTagMatches.map(getCheerioImgFromMatch);
    const htmlMatchesToMediaItemNodesMap = await fetchNodeHtmlImageMediaItemNodes({
      cheerioImages,
      nodeString,
      node,
      helpers,
      pluginOptions
    }); // generate gatsby images for each cheerioImage

    const htmlMatchesWithImageResizes = await Promise.all(imgTagMatches.map(async ({
      match
    }) => {
      var _imageNode$mediaDetai, _pluginOptions$html2, _ref, _pluginOptions$html3;

      const matchInfo = htmlMatchesToMediaItemNodesMap.get(match);

      if (!matchInfo) {
        return null;
      }

      const {
        imageNode,
        cheerioImg
      } = matchInfo;
      const isMediaItemNode = imageNode.__typename === `MediaItem`;

      if (!imageNode) {
        return null;
      }

      const fileNode = // if we couldn't get a MediaItem node for this image in WPGQL
      !isMediaItemNode ? // this will already be a file node
      imageNode : // otherwise grab the file node
      helpers.getNode(imageNode.localFile.id);
      const imgTagMaxWidth = findImgTagMaxWidthFromCheerioImg(cheerioImg);
      const mediaItemNodeWidth = isMediaItemNode ? imageNode === null || imageNode === void 0 ? void 0 : (_imageNode$mediaDetai = imageNode.mediaDetails) === null || _imageNode$mediaDetai === void 0 ? void 0 : _imageNode$mediaDetai.width : null; // if a max width can't be inferred from html, this value will be passed to Sharp

      let fallbackImageMaxWidth = pluginOptions === null || pluginOptions === void 0 ? void 0 : (_pluginOptions$html2 = pluginOptions.html) === null || _pluginOptions$html2 === void 0 ? void 0 : _pluginOptions$html2.fallbackImageMaxWidth;

      if ( // if the image is smaller than the fallback max width,
      // the images width will be used instead if we have a media item node
      fallbackImageMaxWidth > mediaItemNodeWidth && // of course that means we have to have a media item node
      // and a media item node max width
      mediaItemNodeWidth && typeof mediaItemNodeWidth === `number` && mediaItemNodeWidth > 0) {
        fallbackImageMaxWidth = mediaItemNodeWidth;
      }

      const maxWidth = // if we inferred a maxwidth from html
      (_ref = imgTagMaxWidth && // and we have a media item node to know it's full size max width
      mediaItemNodeWidth && // and this isn't an svg which has no maximum width
      fileNode.extension !== `svg` && // and the media item node max width is smaller than what we inferred
      // from html
      mediaItemNodeWidth < imgTagMaxWidth ? // use the media item node width
      mediaItemNodeWidth : // otherwise use the width inferred from html
      imgTagMaxWidth) !== null && _ref !== void 0 ? _ref : // if we don't have a media item node and we inferred no width
      // from html, then use the fallback max width from plugin options
      fallbackImageMaxWidth;
      const quality = pluginOptions === null || pluginOptions === void 0 ? void 0 : (_pluginOptions$html3 = pluginOptions.html) === null || _pluginOptions$html3 === void 0 ? void 0 : _pluginOptions$html3.imageQuality;
      const {
        reporter,
        cache,
        pathPrefix
      } = helpers;
      const gatsbyTransformerSharpSupportsThisFileType = _supportedExtensions.supportedExtensions[fileNode === null || fileNode === void 0 ? void 0 : fileNode.extension];
      let fluidResult = null;

      if (gatsbyTransformerSharpSupportsThisFileType) {
        try {
          fluidResult = await (0, _gatsbyPluginSharp.fluid)({
            file: fileNode,
            args: {
              maxWidth,
              quality,
              pathPrefix
            },
            reporter,
            cache
          });
        } catch (e) {
          reporter.error(e);
          reporter.warn((0, _formatLogMessage.formatLogMessage)(`${node.__typename} ${node.id} couldn't process inline html image ${fileNode.url}`));
          return null;
        }
      }

      return {
        match,
        cheerioImg,
        fileNode,
        imageResize: fluidResult,
        maxWidth
      };
    })); // find/replace mutate nodeString to replace matched images with rendered gatsby images

    for (const matchResize of htmlMatchesWithImageResizes) {
      var _cheerioImg$attribs, _cheerioImg$attribs2;

      if (!matchResize) {
        continue;
      }

      const {
        match,
        imageResize,
        cheerioImg,
        maxWidth
      } = matchResize; // @todo retain img tag classes and attributes from cheerioImg

      const imgOptions = {
        style: {
          // these styles make it so that the image wont be stretched
          // beyond it's max width, but it also wont exceed the width
          // of it's parent element
          maxWidth: "100%",
          width: `${maxWidth}px`
        },
        placeholderStyle: {
          opacity: 0
        },
        className: cheerioImg === null || cheerioImg === void 0 ? void 0 : (_cheerioImg$attribs = cheerioImg.attribs) === null || _cheerioImg$attribs === void 0 ? void 0 : _cheerioImg$attribs.class,
        // Force show full image instantly
        loading: "eager",
        alt: cheerioImg === null || cheerioImg === void 0 ? void 0 : (_cheerioImg$attribs2 = cheerioImg.attribs) === null || _cheerioImg$attribs2 === void 0 ? void 0 : _cheerioImg$attribs2.alt,
        fadeIn: true,
        imgStyle: {
          opacity: 1
        }
      };
      let ReactGatsbyImage;

      if (imageResize) {
        imgOptions.fluid = imageResize;
        ReactGatsbyImage = /*#__PURE__*/_react.default.createElement(_gatsbyImage.default, imgOptions, null);
      } else {
        var _helpers$pathPrefix;

        const {
          fileNode
        } = matchResize;
        const fileName = `${fileNode.internal.contentDigest}/${fileNode.base}`;

        const publicPath = _path.default.join(process.cwd(), `public`, `static`, fileName);

        if (!_fsExtra.default.existsSync(publicPath)) {
          await _fsExtra.default.copy(fileNode.absolutePath, publicPath, {
            dereference: true
          }, err => {
            if (err) {
              console.error(`error copying file from ${fileNode.absolutePath} to ${publicPath}`, err);
            }
          });
        }

        const relativeUrl = `${(_helpers$pathPrefix = helpers.pathPrefix) !== null && _helpers$pathPrefix !== void 0 ? _helpers$pathPrefix : ``}/static/${fileName}`;
        imgOptions.src = relativeUrl;
        delete imgOptions.imgStyle;
        delete imgOptions.fadeIn;
        delete imgOptions.placeholderStyle;
        ReactGatsbyImage = /*#__PURE__*/_react.default.createElement(`img`, imgOptions, null);
      }

      const gatsbyImageStringJSON = JSON.stringify(_server.default.renderToString(ReactGatsbyImage)); // need to remove the JSON stringify quotes around our image since we're
      // threading this JSON string back into a larger JSON object string

      const gatsbyImageString = gatsbyImageStringJSON.substring(1, gatsbyImageStringJSON.length - 1); // replace match with react string in nodeString

      nodeString = nodeString.replace(match, gatsbyImageString);
    }
  }

  return nodeString;
}; // replaces any url which is a front-end WP url with a relative path


const replaceNodeHtmlLinks = ({
  wpUrl,
  nodeString,
  node
}) => {
  const wpLinkRegex = new RegExp(`["']${wpUrl}(?!/wp-content|/wp-admin|/wp-includes)(/[^'"]+)["']`, `gim`);
  const linkMatches = (0, _execall.default)(wpLinkRegex, nodeString);

  if (linkMatches.length) {
    linkMatches.forEach(({
      match,
      subMatches: [path]
    }) => {
      if (path) {
        try {
          // remove \, " and ' characters from match
          const normalizedMatch = match.replace(/['"\\]/g, ``);
          const normalizedPath = path.replace(/\\/g, ``); // replace normalized match with relative path

          const thisMatchRegex = new RegExp(normalizedMatch, `g`);
          nodeString = nodeString.replace(thisMatchRegex, normalizedPath);
        } catch (e) {
          console.error(e);
          console.warning((0, _formatLogMessage.formatLogMessage)(`Failed to process inline html links in ${node.__typename} ${node.id}`));
        }
      }
    });
  }

  return nodeString;
};

const processNodeString = async ({
  nodeString,
  node,
  pluginOptions,
  helpers,
  wpUrl
}) => {
  const nodeStringFilters = [replaceNodeHtmlImages, replaceNodeHtmlLinks];

  for (const nodeStringFilter of nodeStringFilters) {
    nodeString = await nodeStringFilter({
      nodeString,
      node,
      pluginOptions,
      helpers,
      wpUrl
    });
  }

  return nodeString;
};

const processNode = async ({
  node,
  pluginOptions,
  wpUrl,
  helpers,
  referencedMediaItemNodeIds
}) => {
  const nodeString = (0, _fastJsonStableStringify.default)(node); // find referenced node ids
  // here we're searching for node id strings in our node
  // we use this to download only the media items
  // that are being used in posts
  // this is important for downloading images nodes that are connected somewhere
  // on a node field

  const nodeMediaItemIdReferences = findReferencedImageNodeIds({
    nodeString,
    pluginOptions,
    node
  }); // push them to our store of referenced id's

  if ((nodeMediaItemIdReferences === null || nodeMediaItemIdReferences === void 0 ? void 0 : nodeMediaItemIdReferences.length) && referencedMediaItemNodeIds) {
    nodeMediaItemIdReferences.forEach(id => referencedMediaItemNodeIds.add(id));
  }

  const processedNodeString = await processNodeString({
    nodeString,
    node,
    pluginOptions,
    helpers,
    wpUrl
  }); // only parse if the nodeString has changed

  if (processedNodeString !== nodeString) {
    return JSON.parse(processedNodeString);
  } else {
    return node;
  }
};

exports.processNode = processNode;