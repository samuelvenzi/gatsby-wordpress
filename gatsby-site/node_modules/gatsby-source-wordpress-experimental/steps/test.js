"use strict";

exports.__esModule = true;
exports.inlineImages = void 0;

require("source-map-support/register");

const _ = require(`lodash`);

const React = require(`react`);

const ReactDOMServer = require(`react-dom/server`);

const cheerio = require(`cheerio`);

const {
  createRemoteFileNode
} = require(`gatsby-source-filesystem`);

const {
  fluid
} = require(`gatsby-plugin-sharp`);

const Img = require(`gatsby-image`);

function parseWPImagePath(urlpath) {
  const imageSizesPattern = new RegExp("(?:[-_]([0-9]+)x([0-9]+))");
  const sizesMatch = urlpath.match(imageSizesPattern);
  const urlpath_remove_sizes = urlpath.replace(imageSizesPattern, "");
  const result = {
    cleanUrl: urlpath_remove_sizes,
    originalUrl: urlpath
  };

  if (sizesMatch) {
    ;
    result.width = Number(sizesMatch[1]), result.height = Number(sizesMatch[2]);
  }

  return result;
}

const inlineImages = async ({
  getNodes,
  cache,
  reporter,
  store,
  actions,
  createNodeId
}, pluginOptions) => {
  const {
    createNode
  } = actions;
  const defaults = {
    maxWidth: 650,
    wrapperStyle: ``,
    backgroundColor: `white`,
    postTypes: ["Post", "Page"],
    withWebp: false,
    useACF: false // linkImagesToOriginal: true,
    // showCaptions: false,
    // pathPrefix,
    // withWebp: false

  };

  const options = _.defaults(pluginOptions, defaults);

  const nodes = getNodes(); // for now just get all posts and pages.
  // this will be dynamic later
  // console.log(nodes)

  const entities = nodes.filter(node => node.internal.owner === "gatsby-source-wordpress-experimental" && options.postTypes.includes(node.type)); // we need to await transforming all the entities since we may need to get images remotely and generating fluid image data is async

  await Promise.all(entities.map(async entity => transformInlineImagestoStaticImages({
    entity,
    cache,
    reporter,
    store,
    createNode,
    createNodeId
  }, options)));
  console.log("PYP", entities);
};

exports.inlineImages = inlineImages;

const transformInlineImagestoStaticImages = async ({
  entity,
  cache,
  reporter,
  store,
  createNode,
  createNodeId,
  attribute
}, options) => {
  const field = entity[attribute || "content"];

  if (attribute) {
    // If attribute is defined, we're checking some ACF entity
    if (typeof field === "object" && field !== null) {
      // If the ACF entity is an object, parse all its entries recursively
      Object.keys(field).map(async key => {
        await transformInlineImagestoStaticImages({
          entity: field,
          attribute: key,
          cache,
          reporter,
          store,
          createNode,
          createNodeId
        }, options);
      });
      return;
    } // [implicit else] If ACF is not an object, "field" will be parsed later

  } else {
    // If attribute is not defined, we're parsing a top-level node
    // so we should check this entity's ACF attributes
    if (options.useACF && entity.acf) {
      await transformInlineImagestoStaticImages({
        entity: entity,
        attribute: "acf",
        cache,
        reporter,
        store,
        createNode,
        createNodeId
      }, options);
    }
  }

  if (!field && typeof field !== "string" || !field.includes("<img")) return;
  const $ = cheerio.load(field, {
    xmlMode: true
  });
  const imgs = $(`img`);
  if (imgs.length === 0) return;
  let imageRefs = [];
  imgs.each(function () {
    let img = $(this);

    if (img.attr("src")) {
      imageRefs.push(img);
    }
  });
  await Promise.all(imageRefs.map(thisImg => replaceImage({
    thisImg,
    options,
    cache,
    reporter,
    $,
    store,
    createNode,
    createNodeId
  })));
  entity[attribute || "content"] = $.html();
};

const replaceImage = async ({
  thisImg,
  options,
  cache,
  store,
  createNode,
  createNodeId,
  reporter,
  $
}) => {
  // find the full size image that matches, throw away WP resizes
  const parsedUrlData = parseWPImagePath(thisImg.attr("src"));
  const url = parsedUrlData.cleanUrl;
  const {
    originalUrl
  } = parsedUrlData;
  let imageNode; // Try to download the full size image without the WP resize parameters (removed on parse)

  try {
    imageNode = await downloadMediaFile({
      url,
      cache,
      store,
      createNode,
      createNodeId
    });
  } catch (e) {
    // If the image without WP resize parameters on the URL does not exist it means that the original file has sizes
    // Try to download the image with the original URL
    try {
      imageNode = await downloadMediaFile({
        url: originalUrl,
        cache,
        store,
        createNode,
        createNodeId
      });
    } catch (e) {// Do nothing
    }
  }

  if (!imageNode) return;
  let classes = thisImg.attr("class");
  let formattedImgTag = {};
  formattedImgTag.url = thisImg.attr(`src`);
  formattedImgTag.classList = classes ? classes.split(" ") : [];
  formattedImgTag.title = thisImg.attr(`title`);
  formattedImgTag.alt = thisImg.attr(`alt`);
  if (parsedUrlData.width) formattedImgTag.width = parsedUrlData.width;
  if (parsedUrlData.height) formattedImgTag.height = parsedUrlData.height;
  if (!formattedImgTag.url) return;
  const fileType = imageNode.ext; // Ignore gifs as we can't process them,
  // svgs as they are already responsive by definition

  if (fileType !== `gif` && fileType !== `svg`) {
    const rawHTML = await generateImagesAndUpdateNode({
      formattedImgTag,
      imageNode,
      options,
      cache,
      reporter,
      $
    }); // Replace the image string

    if (rawHTML) thisImg.replaceWith(rawHTML);
  }
}; // Takes a node and generates the needed images and then returns
// the needed HTML replacement for the image


const generateImagesAndUpdateNode = async function ({
  formattedImgTag,
  imageNode,
  options,
  cache,
  reporter,
  $
}) {
  if (!imageNode || !imageNode.absolutePath) return;
  let fluidResultWebp;
  let fluidResult = await fluid({
    file: imageNode,
    args: Object.assign(Object.assign({}, options), {}, {
      maxWidth: formattedImgTag.width || options.maxWidth
    }),
    reporter,
    cache
  });

  if (options.withWebp) {
    fluidResultWebp = await fluid({
      file: imageNode,
      args: Object.assign(Object.assign({}, options), {}, {
        maxWidth: formattedImgTag.width || options.maxWidth,
        toFormat: "WEBP"
      }),
      reporter,
      cache
    });
  }

  if (!fluidResult) return;

  if (options.withWebp) {
    fluidResult.srcSetWebp = fluidResultWebp.srcSet;
  }

  const imgOptions = {
    fluid: fluidResult,
    style: {
      maxWidth: "100%"
    },
    // Force show full image instantly
    // critical: true, // depricated
    loading: "eager",
    alt: formattedImgTag.alt,
    // fadeIn: true,
    imgStyle: {
      opacity: 1
    }
  };
  if (formattedImgTag.width) imgOptions.style.width = formattedImgTag.width;
  const ReactImgEl = React.createElement(Img.default, imgOptions, null);
  return ReactDOMServer.renderToString(ReactImgEl);
};

const downloadMediaFile = async ({
  url,
  cache,
  store,
  createNode,
  createNodeId
}) => {
  // const mediaDataCacheKey = `wordpress-media-${e.wordpress_id}`
  // const cacheMediaData = await cache.get(mediaDataCacheKey)
  // // If we have cached media data and it wasn't modified, reuse
  // // previously created file node to not try to redownload
  // if (cacheMediaData && e.modified === cacheMediaData.modified) {
  //   fileNodeID = cacheMediaData.fileNodeID
  //   touchNode({ nodeId: cacheMediaData.fileNodeID })
  // }
  // If we don't have cached data, download the file
  // if (!fileNodeID) {
  let fileNode = false;

  try {
    fileNode = await createRemoteFileNode({
      url,
      store,
      cache,
      createNode,
      createNodeId
    }); // auth: _auth,
    // if (fileNode) {
    //   fileNodeID = fileNode.id
    //   // await cache.set(mediaDataCacheKey, {
    //   //   fileNodeID,
    //   //   modified: e.modified,
    //   // })
    // }
  } catch (e) {
    throw Error(e);
  } // }


  return fileNode; // if (fileNodeID) {
  //   e.localFile___NODE = fileNodeID
  //   delete e.media_details.sizes
  // }
  // return e
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zdGVwcy90ZXN0LmpzIl0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwiUmVhY3QiLCJSZWFjdERPTVNlcnZlciIsImNoZWVyaW8iLCJjcmVhdGVSZW1vdGVGaWxlTm9kZSIsImZsdWlkIiwiSW1nIiwicGFyc2VXUEltYWdlUGF0aCIsInVybHBhdGgiLCJpbWFnZVNpemVzUGF0dGVybiIsIlJlZ0V4cCIsInNpemVzTWF0Y2giLCJtYXRjaCIsInVybHBhdGhfcmVtb3ZlX3NpemVzIiwicmVwbGFjZSIsInJlc3VsdCIsImNsZWFuVXJsIiwib3JpZ2luYWxVcmwiLCJ3aWR0aCIsIk51bWJlciIsImhlaWdodCIsImlubGluZUltYWdlcyIsImdldE5vZGVzIiwiY2FjaGUiLCJyZXBvcnRlciIsInN0b3JlIiwiYWN0aW9ucyIsImNyZWF0ZU5vZGVJZCIsInBsdWdpbk9wdGlvbnMiLCJjcmVhdGVOb2RlIiwiZGVmYXVsdHMiLCJtYXhXaWR0aCIsIndyYXBwZXJTdHlsZSIsImJhY2tncm91bmRDb2xvciIsInBvc3RUeXBlcyIsIndpdGhXZWJwIiwidXNlQUNGIiwib3B0aW9ucyIsIm5vZGVzIiwiZW50aXRpZXMiLCJmaWx0ZXIiLCJub2RlIiwiaW50ZXJuYWwiLCJvd25lciIsImluY2x1ZGVzIiwidHlwZSIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJlbnRpdHkiLCJ0cmFuc2Zvcm1JbmxpbmVJbWFnZXN0b1N0YXRpY0ltYWdlcyIsImNvbnNvbGUiLCJsb2ciLCJhdHRyaWJ1dGUiLCJmaWVsZCIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJhY2YiLCIkIiwibG9hZCIsInhtbE1vZGUiLCJpbWdzIiwibGVuZ3RoIiwiaW1hZ2VSZWZzIiwiZWFjaCIsImltZyIsImF0dHIiLCJwdXNoIiwidGhpc0ltZyIsInJlcGxhY2VJbWFnZSIsImh0bWwiLCJwYXJzZWRVcmxEYXRhIiwidXJsIiwiaW1hZ2VOb2RlIiwiZG93bmxvYWRNZWRpYUZpbGUiLCJlIiwiY2xhc3NlcyIsImZvcm1hdHRlZEltZ1RhZyIsImNsYXNzTGlzdCIsInNwbGl0IiwidGl0bGUiLCJhbHQiLCJmaWxlVHlwZSIsImV4dCIsInJhd0hUTUwiLCJnZW5lcmF0ZUltYWdlc0FuZFVwZGF0ZU5vZGUiLCJyZXBsYWNlV2l0aCIsImFic29sdXRlUGF0aCIsImZsdWlkUmVzdWx0V2VicCIsImZsdWlkUmVzdWx0IiwiZmlsZSIsImFyZ3MiLCJ0b0Zvcm1hdCIsInNyY1NldFdlYnAiLCJzcmNTZXQiLCJpbWdPcHRpb25zIiwic3R5bGUiLCJsb2FkaW5nIiwiaW1nU3R5bGUiLCJvcGFjaXR5IiwiUmVhY3RJbWdFbCIsImNyZWF0ZUVsZW1lbnQiLCJkZWZhdWx0IiwicmVuZGVyVG9TdHJpbmciLCJmaWxlTm9kZSIsIkVycm9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsTUFBTUEsQ0FBQyxHQUFHQyxPQUFPLENBQUUsUUFBRixDQUFqQjs7QUFDQSxNQUFNQyxLQUFLLEdBQUdELE9BQU8sQ0FBRSxPQUFGLENBQXJCOztBQUNBLE1BQU1FLGNBQWMsR0FBR0YsT0FBTyxDQUFFLGtCQUFGLENBQTlCOztBQUNBLE1BQU1HLE9BQU8sR0FBR0gsT0FBTyxDQUFFLFNBQUYsQ0FBdkI7O0FBQ0EsTUFBTTtBQUFFSSxFQUFBQTtBQUFGLElBQTJCSixPQUFPLENBQUUsMEJBQUYsQ0FBeEM7O0FBQ0EsTUFBTTtBQUFFSyxFQUFBQTtBQUFGLElBQVlMLE9BQU8sQ0FBRSxxQkFBRixDQUF6Qjs7QUFDQSxNQUFNTSxHQUFHLEdBQUdOLE9BQU8sQ0FBRSxjQUFGLENBQW5COztBQUVBLFNBQVNPLGdCQUFULENBQTBCQyxPQUExQixFQUFtQztBQUNqQyxRQUFNQyxpQkFBaUIsR0FBRyxJQUFJQyxNQUFKLENBQVcsMkJBQVgsQ0FBMUI7QUFDQSxRQUFNQyxVQUFVLEdBQUdILE9BQU8sQ0FBQ0ksS0FBUixDQUFjSCxpQkFBZCxDQUFuQjtBQUNBLFFBQU1JLG9CQUFvQixHQUFHTCxPQUFPLENBQUNNLE9BQVIsQ0FBZ0JMLGlCQUFoQixFQUFt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LEVBQUFBLEtBSCtCO0FBSS9CSSxFQUFBQSxVQUorQjtBQUsvQkYsRUFBQUE7QUFMK0IsQ0FBUCxLQU1wQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0EsTUFBSThFLFFBQVEsR0FBRyxLQUFmOztBQUNBLE1BQUk7QUFDRkEsSUFBQUEsUUFBUSxHQUFHLE1BQU1yRyxvQkFBb0IsQ0FBQztBQUNwQ3FFLE1BQUFBLEdBRG9DO0FBRXBDaEQsTUFBQUEsS0FGb0M7QUFHcENGLE1BQUFBLEtBSG9DO0FBSXBDTSxNQUFBQSxVQUpvQztBQUtwQ0YsTUFBQUE7QUFMb0MsS0FBRCxDQUFyQyxDQURFLENBUUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNELEdBaEJELENBZ0JFLE9BQU9pRCxDQUFQLEVBQVU7QUFDVixVQUFNOEIsS0FBSyxDQUFDOUIsQ0FBRCxDQUFYO0FBQ0QsR0EvQkcsQ0FnQ0o7OztBQUVBLFNBQU82QixRQUFQLENBbENJLENBbUNKO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDRCxDQS9DRCIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IF8gPSByZXF1aXJlKGBsb2Rhc2hgKVxuY29uc3QgUmVhY3QgPSByZXF1aXJlKGByZWFjdGApXG5jb25zdCBSZWFjdERPTVNlcnZlciA9IHJlcXVpcmUoYHJlYWN0LWRvbS9zZXJ2ZXJgKVxuY29uc3QgY2hlZXJpbyA9IHJlcXVpcmUoYGNoZWVyaW9gKVxuY29uc3QgeyBjcmVhdGVSZW1vdGVGaWxlTm9kZSB9ID0gcmVxdWlyZShgZ2F0c2J5LXNvdXJjZS1maWxlc3lzdGVtYClcbmNvbnN0IHsgZmx1aWQgfSA9IHJlcXVpcmUoYGdhdHNieS1wbHVnaW4tc2hhcnBgKVxuY29uc3QgSW1nID0gcmVxdWlyZShgZ2F0c2J5LWltYWdlYClcblxuZnVuY3Rpb24gcGFyc2VXUEltYWdlUGF0aCh1cmxwYXRoKSB7XG4gIGNvbnN0IGltYWdlU2l6ZXNQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIig/OlstX10oWzAtOV0rKXgoWzAtOV0rKSlcIilcbiAgY29uc3Qgc2l6ZXNNYXRjaCA9IHVybHBhdGgubWF0Y2goaW1hZ2VTaXplc1BhdHRlcm4pXG4gIGNvbnN0IHVybHBhdGhfcmVtb3ZlX3NpemVzID0gdXJscGF0aC5yZXBsYWNlKGltYWdlU2l6ZXNQYXR0ZXJuLCBcIlwiKVxuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBjbGVhblVybDogdXJscGF0aF9yZW1vdmVfc2l6ZXMsXG4gICAgb3JpZ2luYWxVcmw6IHVybHBhdGgsXG4gIH1cblxuICBpZiAoc2l6ZXNNYXRjaCkge1xuICAgIDsocmVzdWx0LndpZHRoID0gTnVtYmVyKHNpemVzTWF0Y2hbMV0pKSxcbiAgICAgIChyZXN1bHQuaGVpZ2h0ID0gTnVtYmVyKHNpemVzTWF0Y2hbMl0pKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgY29uc3QgaW5saW5lSW1hZ2VzID0gYXN5bmMgKFxuICB7IGdldE5vZGVzLCBjYWNoZSwgcmVwb3J0ZXIsIHN0b3JlLCBhY3Rpb25zLCBjcmVhdGVOb2RlSWQgfSxcbiAgcGx1Z2luT3B0aW9uc1xuKSA9PiB7XG4gIGNvbnN0IHsgY3JlYXRlTm9kZSB9ID0gYWN0aW9uc1xuXG4gIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgIG1heFdpZHRoOiA2NTAsXG4gICAgd3JhcHBlclN0eWxlOiBgYCxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGB3aGl0ZWAsXG4gICAgcG9zdFR5cGVzOiBbXCJQb3N0XCIsIFwiUGFnZVwiXSxcbiAgICB3aXRoV2VicDogZmFsc2UsXG4gICAgdXNlQUNGOiBmYWxzZSxcbiAgICAvLyBsaW5rSW1hZ2VzVG9PcmlnaW5hbDogdHJ1ZSxcbiAgICAvLyBzaG93Q2FwdGlvbnM6IGZhbHNlLFxuICAgIC8vIHBhdGhQcmVmaXgsXG4gICAgLy8gd2l0aFdlYnA6IGZhbHNlXG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gXy5kZWZhdWx0cyhwbHVnaW5PcHRpb25zLCBkZWZhdWx0cylcblxuICBjb25zdCBub2RlcyA9IGdldE5vZGVzKClcblxuICAvLyBmb3Igbm93IGp1c3QgZ2V0IGFsbCBwb3N0cyBhbmQgcGFnZXMuXG4gIC8vIHRoaXMgd2lsbCBiZSBkeW5hbWljIGxhdGVyXG4gIC8vIGNvbnNvbGUubG9nKG5vZGVzKVxuICBjb25zdCBlbnRpdGllcyA9IG5vZGVzLmZpbHRlcihcbiAgICAobm9kZSkgPT5cbiAgICAgIG5vZGUuaW50ZXJuYWwub3duZXIgPT09IFwiZ2F0c2J5LXNvdXJjZS13b3JkcHJlc3MtZXhwZXJpbWVudGFsXCIgJiZcbiAgICAgIG9wdGlvbnMucG9zdFR5cGVzLmluY2x1ZGVzKG5vZGUudHlwZSlcbiAgKVxuXG4gIC8vIHdlIG5lZWQgdG8gYXdhaXQgdHJhbnNmb3JtaW5nIGFsbCB0aGUgZW50aXRpZXMgc2luY2Ugd2UgbWF5IG5lZWQgdG8gZ2V0IGltYWdlcyByZW1vdGVseSBhbmQgZ2VuZXJhdGluZyBmbHVpZCBpbWFnZSBkYXRhIGlzIGFzeW5jXG4gIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGVudGl0aWVzLm1hcChhc3luYyAoZW50aXR5KSA9PlxuICAgICAgdHJhbnNmb3JtSW5saW5lSW1hZ2VzdG9TdGF0aWNJbWFnZXMoXG4gICAgICAgIHtcbiAgICAgICAgICBlbnRpdHksXG4gICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgcmVwb3J0ZXIsXG4gICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgY3JlYXRlTm9kZSxcbiAgICAgICAgICBjcmVhdGVOb2RlSWQsXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIClcbiAgICApXG4gIClcbiAgY29uc29sZS5sb2coXCJQWVBcIiwgZW50aXRpZXMpXG59XG5cbmNvbnN0IHRyYW5zZm9ybUlubGluZUltYWdlc3RvU3RhdGljSW1hZ2VzID0gYXN5bmMgKFxuICB7IGVudGl0eSwgY2FjaGUsIHJlcG9ydGVyLCBzdG9yZSwgY3JlYXRlTm9kZSwgY3JlYXRlTm9kZUlkLCBhdHRyaWJ1dGUgfSxcbiAgb3B0aW9uc1xuKSA9PiB7XG4gIGNvbnN0IGZpZWxkID0gZW50aXR5W2F0dHJpYnV0ZSB8fCBcImNvbnRlbnRcIl1cblxuICBpZiAoYXR0cmlidXRlKSB7XG4gICAgLy8gSWYgYXR0cmlidXRlIGlzIGRlZmluZWQsIHdlJ3JlIGNoZWNraW5nIHNvbWUgQUNGIGVudGl0eVxuICAgIGlmICh0eXBlb2YgZmllbGQgPT09IFwib2JqZWN0XCIgJiYgZmllbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZSBBQ0YgZW50aXR5IGlzIGFuIG9iamVjdCwgcGFyc2UgYWxsIGl0cyBlbnRyaWVzIHJlY3Vyc2l2ZWx5XG4gICAgICBPYmplY3Qua2V5cyhmaWVsZCkubWFwKGFzeW5jIChrZXkpID0+IHtcbiAgICAgICAgYXdhaXQgdHJhbnNmb3JtSW5saW5lSW1hZ2VzdG9TdGF0aWNJbWFnZXMoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW50aXR5OiBmaWVsZCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZToga2V5LFxuICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICByZXBvcnRlcixcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgY3JlYXRlTm9kZSxcbiAgICAgICAgICAgIGNyZWF0ZU5vZGVJZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH0gLy8gW2ltcGxpY2l0IGVsc2VdIElmIEFDRiBpcyBub3QgYW4gb2JqZWN0LCBcImZpZWxkXCIgd2lsbCBiZSBwYXJzZWQgbGF0ZXJcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhdHRyaWJ1dGUgaXMgbm90IGRlZmluZWQsIHdlJ3JlIHBhcnNpbmcgYSB0b3AtbGV2ZWwgbm9kZVxuICAgIC8vIHNvIHdlIHNob3VsZCBjaGVjayB0aGlzIGVudGl0eSdzIEFDRiBhdHRyaWJ1dGVzXG4gICAgaWYgKG9wdGlvbnMudXNlQUNGICYmIGVudGl0eS5hY2YpIHtcbiAgICAgIGF3YWl0IHRyYW5zZm9ybUlubGluZUltYWdlc3RvU3RhdGljSW1hZ2VzKFxuICAgICAgICB7XG4gICAgICAgICAgZW50aXR5OiBlbnRpdHksXG4gICAgICAgICAgYXR0cmlidXRlOiBcImFjZlwiLFxuICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgIHJlcG9ydGVyLFxuICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgIGNyZWF0ZU5vZGUsXG4gICAgICAgICAgY3JlYXRlTm9kZUlkLFxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgaWYgKCghZmllbGQgJiYgdHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSB8fCAhZmllbGQuaW5jbHVkZXMoXCI8aW1nXCIpKSByZXR1cm5cblxuICBjb25zdCAkID0gY2hlZXJpby5sb2FkKGZpZWxkLCB7XG4gICAgeG1sTW9kZTogdHJ1ZSxcbiAgfSlcblxuICBjb25zdCBpbWdzID0gJChgaW1nYClcblxuICBpZiAoaW1ncy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGxldCBpbWFnZVJlZnMgPSBbXVxuXG4gIGltZ3MuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGltZyA9ICQodGhpcylcbiAgICBpZiAoaW1nLmF0dHIoXCJzcmNcIikpIHtcbiAgICAgIGltYWdlUmVmcy5wdXNoKGltZylcbiAgICB9XG4gIH0pXG5cbiAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgaW1hZ2VSZWZzLm1hcCgodGhpc0ltZykgPT5cbiAgICAgIHJlcGxhY2VJbWFnZSh7XG4gICAgICAgIHRoaXNJbWcsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICByZXBvcnRlcixcbiAgICAgICAgJCxcbiAgICAgICAgc3RvcmUsXG4gICAgICAgIGNyZWF0ZU5vZGUsXG4gICAgICAgIGNyZWF0ZU5vZGVJZCxcbiAgICAgIH0pXG4gICAgKVxuICApXG5cbiAgZW50aXR5W2F0dHJpYnV0ZSB8fCBcImNvbnRlbnRcIl0gPSAkLmh0bWwoKVxufVxuXG5jb25zdCByZXBsYWNlSW1hZ2UgPSBhc3luYyAoe1xuICB0aGlzSW1nLFxuICBvcHRpb25zLFxuICBjYWNoZSxcbiAgc3RvcmUsXG4gIGNyZWF0ZU5vZGUsXG4gIGNyZWF0ZU5vZGVJZCxcbiAgcmVwb3J0ZXIsXG4gICQsXG59KSA9PiB7XG4gIC8vIGZpbmQgdGhlIGZ1bGwgc2l6ZSBpbWFnZSB0aGF0IG1hdGNoZXMsIHRocm93IGF3YXkgV1AgcmVzaXplc1xuICBjb25zdCBwYXJzZWRVcmxEYXRhID0gcGFyc2VXUEltYWdlUGF0aCh0aGlzSW1nLmF0dHIoXCJzcmNcIikpXG4gIGNvbnN0IHVybCA9IHBhcnNlZFVybERhdGEuY2xlYW5VcmxcbiAgY29uc3QgeyBvcmlnaW5hbFVybCB9ID0gcGFyc2VkVXJsRGF0YVxuICBsZXQgaW1hZ2VOb2RlXG5cbiAgLy8gVHJ5IHRvIGRvd25sb2FkIHRoZSBmdWxsIHNpemUgaW1hZ2Ugd2l0aG91dCB0aGUgV1AgcmVzaXplIHBhcmFtZXRlcnMgKHJlbW92ZWQgb24gcGFyc2UpXG4gIHRyeSB7XG4gICAgaW1hZ2VOb2RlID0gYXdhaXQgZG93bmxvYWRNZWRpYUZpbGUoe1xuICAgICAgdXJsLFxuICAgICAgY2FjaGUsXG4gICAgICBzdG9yZSxcbiAgICAgIGNyZWF0ZU5vZGUsXG4gICAgICBjcmVhdGVOb2RlSWQsXG4gICAgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElmIHRoZSBpbWFnZSB3aXRob3V0IFdQIHJlc2l6ZSBwYXJhbWV0ZXJzIG9uIHRoZSBVUkwgZG9lcyBub3QgZXhpc3QgaXQgbWVhbnMgdGhhdCB0aGUgb3JpZ2luYWwgZmlsZSBoYXMgc2l6ZXNcbiAgICAvLyBUcnkgdG8gZG93bmxvYWQgdGhlIGltYWdlIHdpdGggdGhlIG9yaWdpbmFsIFVSTFxuICAgIHRyeSB7XG4gICAgICBpbWFnZU5vZGUgPSBhd2FpdCBkb3dubG9hZE1lZGlhRmlsZSh7XG4gICAgICAgIHVybDogb3JpZ2luYWxVcmwsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBzdG9yZSxcbiAgICAgICAgY3JlYXRlTm9kZSxcbiAgICAgICAgY3JlYXRlTm9kZUlkLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBEbyBub3RoaW5nXG4gICAgfVxuICB9XG5cbiAgaWYgKCFpbWFnZU5vZGUpIHJldHVyblxuXG4gIGxldCBjbGFzc2VzID0gdGhpc0ltZy5hdHRyKFwiY2xhc3NcIilcbiAgbGV0IGZvcm1hdHRlZEltZ1RhZyA9IHt9XG4gIGZvcm1hdHRlZEltZ1RhZy51cmwgPSB0aGlzSW1nLmF0dHIoYHNyY2ApXG4gIGZvcm1hdHRlZEltZ1RhZy5jbGFzc0xpc3QgPSBjbGFzc2VzID8gY2xhc3Nlcy5zcGxpdChcIiBcIikgOiBbXVxuICBmb3JtYXR0ZWRJbWdUYWcudGl0bGUgPSB0aGlzSW1nLmF0dHIoYHRpdGxlYClcbiAgZm9ybWF0dGVkSW1nVGFnLmFsdCA9IHRoaXNJbWcuYXR0cihgYWx0YClcblxuICBpZiAocGFyc2VkVXJsRGF0YS53aWR0aCkgZm9ybWF0dGVkSW1nVGFnLndpZHRoID0gcGFyc2VkVXJsRGF0YS53aWR0aFxuICBpZiAocGFyc2VkVXJsRGF0YS5oZWlnaHQpIGZvcm1hdHRlZEltZ1RhZy5oZWlnaHQgPSBwYXJzZWRVcmxEYXRhLmhlaWdodFxuXG4gIGlmICghZm9ybWF0dGVkSW1nVGFnLnVybCkgcmV0dXJuXG5cbiAgY29uc3QgZmlsZVR5cGUgPSBpbWFnZU5vZGUuZXh0XG5cbiAgLy8gSWdub3JlIGdpZnMgYXMgd2UgY2FuJ3QgcHJvY2VzcyB0aGVtLFxuICAvLyBzdmdzIGFzIHRoZXkgYXJlIGFscmVhZHkgcmVzcG9uc2l2ZSBieSBkZWZpbml0aW9uXG4gIGlmIChmaWxlVHlwZSAhPT0gYGdpZmAgJiYgZmlsZVR5cGUgIT09IGBzdmdgKSB7XG4gICAgY29uc3QgcmF3SFRNTCA9IGF3YWl0IGdlbmVyYXRlSW1hZ2VzQW5kVXBkYXRlTm9kZSh7XG4gICAgICBmb3JtYXR0ZWRJbWdUYWcsXG4gICAgICBpbWFnZU5vZGUsXG4gICAgICBvcHRpb25zLFxuICAgICAgY2FjaGUsXG4gICAgICByZXBvcnRlcixcbiAgICAgICQsXG4gICAgfSlcblxuICAgIC8vIFJlcGxhY2UgdGhlIGltYWdlIHN0cmluZ1xuICAgIGlmIChyYXdIVE1MKSB0aGlzSW1nLnJlcGxhY2VXaXRoKHJhd0hUTUwpXG4gIH1cbn1cblxuLy8gVGFrZXMgYSBub2RlIGFuZCBnZW5lcmF0ZXMgdGhlIG5lZWRlZCBpbWFnZXMgYW5kIHRoZW4gcmV0dXJuc1xuLy8gdGhlIG5lZWRlZCBIVE1MIHJlcGxhY2VtZW50IGZvciB0aGUgaW1hZ2VcbmNvbnN0IGdlbmVyYXRlSW1hZ2VzQW5kVXBkYXRlTm9kZSA9IGFzeW5jIGZ1bmN0aW9uICh7XG4gIGZvcm1hdHRlZEltZ1RhZyxcbiAgaW1hZ2VOb2RlLFxuICBvcHRpb25zLFxuICBjYWNoZSxcbiAgcmVwb3J0ZXIsXG4gICQsXG59KSB7XG4gIGlmICghaW1hZ2VOb2RlIHx8ICFpbWFnZU5vZGUuYWJzb2x1dGVQYXRoKSByZXR1cm5cblxuICBsZXQgZmx1aWRSZXN1bHRXZWJwXG4gIGxldCBmbHVpZFJlc3VsdCA9IGF3YWl0IGZsdWlkKHtcbiAgICBmaWxlOiBpbWFnZU5vZGUsXG4gICAgYXJnczoge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG1heFdpZHRoOiBmb3JtYXR0ZWRJbWdUYWcud2lkdGggfHwgb3B0aW9ucy5tYXhXaWR0aCxcbiAgICB9LFxuICAgIHJlcG9ydGVyLFxuICAgIGNhY2hlLFxuICB9KVxuXG4gIGlmIChvcHRpb25zLndpdGhXZWJwKSB7XG4gICAgZmx1aWRSZXN1bHRXZWJwID0gYXdhaXQgZmx1aWQoe1xuICAgICAgZmlsZTogaW1hZ2VOb2RlLFxuICAgICAgYXJnczoge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBtYXhXaWR0aDogZm9ybWF0dGVkSW1nVGFnLndpZHRoIHx8IG9wdGlvbnMubWF4V2lkdGgsXG4gICAgICAgIHRvRm9ybWF0OiBcIldFQlBcIixcbiAgICAgIH0sXG4gICAgICByZXBvcnRlcixcbiAgICAgIGNhY2hlLFxuICAgIH0pXG4gIH1cblxuICBpZiAoIWZsdWlkUmVzdWx0KSByZXR1cm5cblxuICBpZiAob3B0aW9ucy53aXRoV2VicCkge1xuICAgIGZsdWlkUmVzdWx0LnNyY1NldFdlYnAgPSBmbHVpZFJlc3VsdFdlYnAuc3JjU2V0XG4gIH1cblxuICBjb25zdCBpbWdPcHRpb25zID0ge1xuICAgIGZsdWlkOiBmbHVpZFJlc3VsdCxcbiAgICBzdHlsZToge1xuICAgICAgbWF4V2lkdGg6IFwiMTAwJVwiLFxuICAgIH0sXG4gICAgLy8gRm9yY2Ugc2hvdyBmdWxsIGltYWdlIGluc3RhbnRseVxuICAgIC8vIGNyaXRpY2FsOiB0cnVlLCAvLyBkZXByaWNhdGVkXG4gICAgbG9hZGluZzogXCJlYWdlclwiLFxuICAgIGFsdDogZm9ybWF0dGVkSW1nVGFnLmFsdCxcbiAgICAvLyBmYWRlSW46IHRydWUsXG4gICAgaW1nU3R5bGU6IHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgfSxcbiAgfVxuICBpZiAoZm9ybWF0dGVkSW1nVGFnLndpZHRoKSBpbWdPcHRpb25zLnN0eWxlLndpZHRoID0gZm9ybWF0dGVkSW1nVGFnLndpZHRoXG5cbiAgY29uc3QgUmVhY3RJbWdFbCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW1nLmRlZmF1bHQsIGltZ09wdGlvbnMsIG51bGwpXG4gIHJldHVybiBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZyhSZWFjdEltZ0VsKVxufVxuXG5jb25zdCBkb3dubG9hZE1lZGlhRmlsZSA9IGFzeW5jICh7XG4gIHVybCxcbiAgY2FjaGUsXG4gIHN0b3JlLFxuICBjcmVhdGVOb2RlLFxuICBjcmVhdGVOb2RlSWQsXG59KSA9PiB7XG4gIC8vIGNvbnN0IG1lZGlhRGF0YUNhY2hlS2V5ID0gYHdvcmRwcmVzcy1tZWRpYS0ke2Uud29yZHByZXNzX2lkfWBcbiAgLy8gY29uc3QgY2FjaGVNZWRpYURhdGEgPSBhd2FpdCBjYWNoZS5nZXQobWVkaWFEYXRhQ2FjaGVLZXkpXG4gIC8vIC8vIElmIHdlIGhhdmUgY2FjaGVkIG1lZGlhIGRhdGEgYW5kIGl0IHdhc24ndCBtb2RpZmllZCwgcmV1c2VcbiAgLy8gLy8gcHJldmlvdXNseSBjcmVhdGVkIGZpbGUgbm9kZSB0byBub3QgdHJ5IHRvIHJlZG93bmxvYWRcbiAgLy8gaWYgKGNhY2hlTWVkaWFEYXRhICYmIGUubW9kaWZpZWQgPT09IGNhY2hlTWVkaWFEYXRhLm1vZGlmaWVkKSB7XG4gIC8vICAgZmlsZU5vZGVJRCA9IGNhY2hlTWVkaWFEYXRhLmZpbGVOb2RlSURcbiAgLy8gICB0b3VjaE5vZGUoeyBub2RlSWQ6IGNhY2hlTWVkaWFEYXRhLmZpbGVOb2RlSUQgfSlcbiAgLy8gfVxuXG4gIC8vIElmIHdlIGRvbid0IGhhdmUgY2FjaGVkIGRhdGEsIGRvd25sb2FkIHRoZSBmaWxlXG4gIC8vIGlmICghZmlsZU5vZGVJRCkge1xuICBsZXQgZmlsZU5vZGUgPSBmYWxzZVxuICB0cnkge1xuICAgIGZpbGVOb2RlID0gYXdhaXQgY3JlYXRlUmVtb3RlRmlsZU5vZGUoe1xuICAgICAgdXJsLFxuICAgICAgc3RvcmUsXG4gICAgICBjYWNoZSxcbiAgICAgIGNyZWF0ZU5vZGUsXG4gICAgICBjcmVhdGVOb2RlSWQsXG4gICAgfSlcbiAgICAvLyBhdXRoOiBfYXV0aCxcbiAgICAvLyBpZiAoZmlsZU5vZGUpIHtcbiAgICAvLyAgIGZpbGVOb2RlSUQgPSBmaWxlTm9kZS5pZFxuICAgIC8vICAgLy8gYXdhaXQgY2FjaGUuc2V0KG1lZGlhRGF0YUNhY2hlS2V5LCB7XG4gICAgLy8gICAvLyAgIGZpbGVOb2RlSUQsXG4gICAgLy8gICAvLyAgIG1vZGlmaWVkOiBlLm1vZGlmaWVkLFxuICAgIC8vICAgLy8gfSlcbiAgICAvLyB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBFcnJvcihlKVxuICB9XG4gIC8vIH1cblxuICByZXR1cm4gZmlsZU5vZGVcbiAgLy8gaWYgKGZpbGVOb2RlSUQpIHtcbiAgLy8gICBlLmxvY2FsRmlsZV9fX05PREUgPSBmaWxlTm9kZUlEXG4gIC8vICAgZGVsZXRlIGUubWVkaWFfZGV0YWlscy5zaXplc1xuICAvLyB9XG5cbiAgLy8gcmV0dXJuIGVcbn1cbiJdfQ==